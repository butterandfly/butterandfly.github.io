{"title":" 理解进程替换（Process Substitution）","createDate":"2015-05-25","url":"data/2015-05-25-understand-process-subsitution.json","fileName":"2015-05-25-understand-process-subsitution","content":"# 理解进程替换（Process Substitution）\n\n## 从read说起\n在学习read命令的时候，我们总会遇到这么一总情形：\n\n```\n# 我们希望把hi通过pipe传进read里\n$ echo “hi” | read\n# 然后通过查看$REPLY来确定，却发现没有REPLY依然为空\n$ echo $REPLY\n```\n\n每一本书都会告诉我们，通过pipe把值传进read中是不起作用的。原因在于，使用pipe时会创建一个subshell，所以read对变量$REPLY的赋值在subshell里。\n\n那么，我怎么把另一个命令执行的结果传到read里呢？别忘了，read读取的是stdin；任何一个文件都可以成为stdin：\n\n```\n# 将hi写入文件\n$ echo hi > test\n# 通过重定向，使read读取文件的内容\n$ read < test\n# $REPLY将会是hi\n$ echo $REPLY\n```\n\n所以，只要把一个命令的结果写进文件，如`ls > filename`，再通过上面方式就能把值赋给$REPLY，实现了一开始的管道功能。简单来说是这样：\n\n* 将命令的执行结果写进文件\n* 用read从文件里读取内容\n* 删除这个作为中间存储器的文件\n\n而进程替换，实际上是一个实现了该功能的语法糖。\n\n## 什么是进程替换\n可参考：http://tldp.org/LDP/abs/html/process-sub.html\n\n```\n<(命令)\n>(命令)\n```\n\n里面的`<()`其实就是一个文件（不管里面的命令如何改变），其角色就是上文中的test文件（中间存储器）：\n\n```\n$ echo <(echo hi) # 显示为/dev/fd/63\n$ ls -l <(echo hi) # 查看该文件信息\n$ cat <(echo hi) # 显示hi，该文件的内容是括号内命令的输出\n```\n\n所以，回到我们的read命令，现在有了一个更简洁的方法：\n\n```\n$ read < <(echo hi)\n```\n\n这就是进程代替。\n"}